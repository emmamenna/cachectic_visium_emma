---
title: "cell_communication"
output: html_document
date: "2025-09-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(arrow)
library(Banksy)
library(BiocParallel)
library(DropletUtils)
library(dplyr)
library(edgeR)
library(ggplot2)
library(graphics)
library(igraph)
library(jsonlite)
library(Matrix)
library(OSTA.data)
library(patchwork)
library(pheatmap)
library(S4Vectors)
library(scDblFinder)
library(scater)
library(scran)
library(scuttle)
library(SingleCellExperiment)
library(SpatialExperiment)
library(SummarizedExperiment)
library(tidyr)
library(VisiumIO)
library(spacexr)
library(SpotSweeper)
library(ggspavis)
library(CellChat)
library(Seurat)
library(SeuratDisk)
library(SpaNorm)
```

#Dataset preparation:
Firstly, genes are filtered in order to keep only genes expressed in at least 1% of the spots 
(the threshold is so low because of the huge amount of genes that have poor detection in the samples, so being conservative seems like the best option).
Secondly, spots that have zero counts or that were identified by deconvolution as NAs (excpet for block 7 -
which we are not considering anymore in the analysis - these correspond to external connective tissue)
are removed. 
Lastly, a normalization accounting for spatial information (spaNorm) is applied.
```{r}
load("~/subset_list.RData")

#removing block 7
subset_list <- subset_list[!names(subset_list) %in% c("c26STAT3_b7","sham_b7","c26_b7")]
cellchat_list <- list()

#spots filtering
subset_list <- lapply(subset_list, function(spe) {
   keep <- !is.na(spe$cell_type) & colSums(counts(spe)) > 0
   spe[,keep]
})

#genes filtering
 subset_list <- lapply(subset_list, function(spe) {
   keep <- filterGenes(spe, prop = 0.01)
   print(table(keep)) 
   spe[keep, ]
})
 
save(subset_list, file = "subset_list_filtered.RData")

#Spatial normalization
subset_list <- lapply(subset_list, function(spe) {
  set.seed(92)
  spe <- SpaNorm(spe, sample.p = 0.10, maxn.psi = 200, maxit.nb=15, maxit.psi = 5, df.tps = 3)
})

save(subset_list, file="~/subset_list_spanorm.RData")

```

#Cell chat separately per sample.
CellChat identifies over-expressed ligands and receptors for each cell type as well as over-expressed ligand-receptor interactions. After that, it associates a probability to these interactions,
which is based on the mean expressions of the ligand and receptor (in their cell types).
Significant interactions are identified according to a permutation test on cell type labels.
Then probabilities refering to ligand-receptor couples belonging to the same biological pathway are merged to detect the strength of the pathway in the tissue and which cell types it involves.

The new version of cell chat allows the use of spatial information: the probability of an interaction
is inversely proportional to their distance. In addition, it allows to look for contact dependent interactions.
```{r}
load("~/subset_list_spanorm.RData")

#spatial information
spatial.factors <- data.frame(
  ratio = 0.316,   # pixel -> micron conversion factor
  tol   = 4    # half the dimension of bins in micron
)

cellchat_list <- lapply(subset_list, function(spx) {
  sce <- as(spx, "SingleCellExperiment")
  chat <- createCellChat(object = sce,
                         datatype = "spatial",
                         group.by = "cell_type",
                         coordinates = spatialCoords(spx),
                         assay ="logcounts",
                         spatial.factors = spatial.factors)
  chat@DB <- CellChatDB.mouse
  # chat@DB.use <-subsetDB(chat@DB,search="Secreted Signaling")
  chat <- subsetData(chat)
  chat <- identifyOverExpressedGenes(chat)
  chat <- identifyOverExpressedInteractions(chat)
  chat <- computeCommunProb(chat, type = "triMean", 
                            distance.use = TRUE,
                            scale.distance = 0.1,
                            k.min = 10, #min. interacting cell pairs for 2 groups to be defined close (default)
                            contact.dependent = TRUE,
                            contact.range = 30)
  chat <- computeCommunProbPathway(chat)
  chat <- aggregateNet(chat)
  chat
})

results <- lapply(cellchat_list, function(x){
  tryCatch({
    df.net <- subsetCommunication(x, slot.name = "netP")
    prob <- df.net %>%
      group_by(pathway_name) %>%
      summarise(sum = sum(prob))
    prob[order(prob$sum, decreasing = TRUE), ]
  }, error = function(e) {
    message("Skipping one CellChat object: ", e$message)
    return(NULL)
  })
})
results

```

#Visualization -> plots are saved in a pdf file for each sample
```{r}
subset_list <- subset_list[!names(subset_list) =="sham_b6"]

# Loop sui campioni
invisible(lapply(names(cellchat_list), function(sample_name) {
  chat <- cellchat_list[[sample_name]]
  pathways.show <- chat@netP$pathways
  
  # pulizia nome file
  safe_name <- gsub("[^[:alnum:]_\\-]", "_", sample_name)
  out_pdf <- paste0("CellChat_Exploratory_", safe_name, ".pdf")
  
  # vertex.receiver default: tutti i cluster
  n_groups <- length(unique(as.character(chat@idents)))
  vertex.receiver <- seq_len(n_groups)
  
  pdf(file = out_pdf, width = 9, height = 9)
  
  ## --- PAGINA INTRO CAMPIONE ---
  tryCatch({
    groupSize <- as.numeric(table(chat@idents))
    par(mfrow = c(1,2), xpd = TRUE)
    
    netVisual_circle(chat@net$count,
                     vertex.weight = groupSize,
                     weight.scale = TRUE,
                     label.edge = FALSE,
                     title.name = "Number of interactions")
    
    netVisual_circle(chat@net$weight,
                     vertex.weight = groupSize,
                     weight.scale = TRUE,
                     label.edge = FALSE,
                     title.name = "Interaction weights/strength")
    
    par(mfrow = c(1,1)) # reset layout
  }, error = function(e){
    message("[", sample_name, "] overview circle plots failed: ", e$message)
  })
  
  ## --- LOOP SUI PATHWAYS ---
  for (pw in pathways.show) {
    # pagina separatore
    grid::grid.newpage()
    grid::grid.text(label = paste0(sample_name, " â€” ", pw),
                    gp = grid::gpar(fontsize = 20, fontface = "bold"))
    
    # 1) Chord
    tryCatch({
      p <- netVisual_aggregate(chat, signaling = pw,
                               layout = "chord",
                               signaling.name = paste0(sample_name, " - ", pw),
                               vertex.label.cex = 0.8,
                               title.space = 10)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] chord failed: ", e$message)})
    
    # 2) Circle
    tryCatch({
      p <- netVisual_aggregate(chat, signaling = pw,
                               layout = "circle",
                               signaling.name = paste0(sample_name, " - ", pw),
                               vertex.label.cex = 0.8,
                               title.space = 10)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] circle failed: ", e$message)})
    
    # 3) Bubble
    tryCatch({
      b <- netVisual_bubble(chat,
                            signaling = pw,
                            remove.isolate = TRUE)
      print(b)
    }, error = function(e){message("[", sample_name,"|",pw,"] bubble failed: ", e$message)})
    
    # 4) Heatmap
    tryCatch({
      p <- netVisual_heatmap(chat, signaling = pw)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] heatmap failed: ", e$message)})
    
    # 5) Contribution (per pathway)
    tryCatch({
      c <- netAnalysis_contribution(chat, signaling = pw)
      print(c)
    }, error = function(e){message("[", sample_name,"|",pw,"] contribution failed: ", e$message)})
  }
  
  dev.off()
  message("Saved exploratory PDF for sample: ", safe_name)
}))

```



