---
title: "cell_chat_trim"
output: html_document
date: "2025-11-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(arrow)
library(Banksy)
library(BiocParallel)
library(DropletUtils)
library(dplyr)
library(edgeR)
library(ggplot2)
library(graphics)
library(igraph)
library(jsonlite)
library(Matrix)
library(OSTA.data)
library(patchwork)
library(pheatmap)
library(S4Vectors)
library(scDblFinder)
library(scater)
library(scran)
library(scuttle)
library(SingleCellExperiment)
library(SpatialExperiment)
library(SummarizedExperiment)
library(tidyr)
library(VisiumIO)
library(spacexr)
library(SpotSweeper)
library(ggspavis)
library(CellChat)
library(Seurat)
library(SeuratDisk)
library(SpaNorm)
```

#approccio1: prendo gli spot dei trim e gli spot adiacenti ai trim
#(secondo me questa cosa a maggior ragione andrebbe fatta sui nuclei però)
```{r}
load("~/subset_list_spanorm.RData")

subset_list <- lapply(subset_list, function(spe) {

  # Distanze tra tutti gli spot
  cell_dist <- computeCellDistance(
    coordinates = spatialCoords(spe),
    ratio = 0.316,
    tol = 4
  )
  cell_dist <- as.matrix(cell_dist)

  # Identifica righe corrispondenti ai nuclei Trim63
  trim_idx <- which(spe$cell_type == "Myonuclei_Trim63")

  # Se non ci sono trim → ritorna spe senza filtri
  if (length(trim_idx) == 0) {
    warning("Nessuno spot Trim63 in questo spe.")
    return(spe)
  }

  # Distanze: righe = Trim, colonne = tutti gli spot
  trim_dist <- cell_dist[trim_idx, , drop = FALSE]

  # Uno spot è "vicino a trim" se almeno un trim dista < 30
  trim_neigh <- apply(trim_dist, 2, function(x) any(x < 30))
  print(prop.table(table(trim_neigh)))

  # Mantieni solo spot vicini ai trim
  spe <- spe[, trim_neigh]

  return(spe)
})

#proporzioni molto variabili come prevedibile a seconda della condizione
#direi che intanto guardo ai c26

subset_list$c26_b2
subset_list$c26_b4
subset_list$c26_b6

c26_list <- subset_list[names(subset_list) %in% c("c26_b2","c26_b4","c26_b6")]

```
```{r}

#spatial information
spatial.factors <- data.frame(
  ratio = 0.316,   # pixel -> micron conversion factor
  tol   = 4    # half the dimension of bins in micron
)

#Uso il codice non contact dependent ma di fatto lo è perché ho già filtrato
set.seed(1733)
cellchat_list <- lapply(c26_list, function(spx) {
  sce <- as(spx, "SingleCellExperiment")
  chat <- createCellChat(object = sce,
                         datatype = "spatial",
                         group.by = "cell_type",
                         coordinates = spatialCoords(spx),
                         assay ="logcounts",
                         spatial.factors = spatial.factors)
  chat@DB <- CellChatDB.mouse
  # chat@DB.use <-subsetDB(chat@DB,search="Secreted Signaling")
  chat <- subsetData(chat)
  chat <- identifyOverExpressedGenes(chat)
  chat <- identifyOverExpressedInteractions(chat)
  chat <- computeCommunProb(chat, type = "triMean", 
                            distance.use = TRUE,
                            scale.distance = 0.1,
                            k.min = 10, #min. interacting cell pairs for 2 groups to be defined close (default)
                            contact.dependent = FALSE) #contact.range = 30
  chat <- computeCommunProbPathway(chat)
  chat <- aggregateNet(chat)
  chat
})

results <- lapply(cellchat_list, function(x){
  tryCatch({
    df.net <- subsetCommunication(x, slot.name = "netP")
    prob <- df.net %>%
      group_by(pathway_name) %>%
      summarise(sum = sum(prob))
    prob[order(prob$sum, decreasing = TRUE), ]
  }, error = function(e) {
    message("Skipping one CellChat object: ", e$message)
    return(NULL)
  })
})
results

```

#approccio2: seleziono solo i tipi cellulari che sono a distanza ravvicinata coi trim
#basandomi sulle tabelle di frequenza
```{r}

```

#Visualization -> plots are saved in a pdf file for each sample
```{r}

# Loop sui campioni
invisible(lapply(names(cellchat_list), function(sample_name) {
  chat <- cellchat_list[[sample_name]]
  pathways.show <- chat@netP$pathways
  
  # pulizia nome file
  safe_name <- gsub("[^[:alnum:]_\\-]", "_", sample_name)
  out_pdf <- paste0("CellChat_Exploratory_", safe_name, ".pdf")
  
  # vertex.receiver default: tutti i cluster
  n_groups <- length(unique(as.character(chat@idents)))
  vertex.receiver <- seq_len(n_groups)
  
  pdf(file = out_pdf, width = 9, height = 9)
  
  ## --- PAGINA INTRO CAMPIONE ---
  tryCatch({
    groupSize <- as.numeric(table(chat@idents))
    par(mfrow = c(1,2), xpd = TRUE)
    
    netVisual_circle(chat@net$count,
                 vertex.weight = groupSize,
                 weight.scale = TRUE,
                 label.edge = FALSE,
                 title.name = "Number of interactions",
                 vertex.label.cex = 0.6)  
    
    netVisual_circle(chat@net$weight,
                     vertex.weight = groupSize,
                     weight.scale = TRUE,
                     label.edge = FALSE,
                     title.name = "Interaction weights/strength",
                     vertex.label.cex = 0.6)
    
    par(mfrow = c(1,1)) # reset layout
  }, error = function(e){
    message("[", sample_name, "] overview circle plots failed: ", e$message)
  })
  
  ## --- LOOP SUI PATHWAYS ---
  for (pw in pathways.show) {
    # pagina separatore
    grid::grid.newpage()
    grid::grid.text(label = paste0(sample_name, " — ", pw),
                    gp = grid::gpar(fontsize = 20, fontface = "bold"))
    
    # 1) Chord
    tryCatch({
      p <- netVisual_aggregate(chat, signaling = pw,
                               layout = "chord",
                               signaling.name = paste0(sample_name, " - ", pw),
                               vertex.label.cex = 0.8,
                               title.space = 10)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] chord failed: ", e$message)})
    
    # 2) Circle
    tryCatch({
      p <- netVisual_aggregate(chat, signaling = pw,
                               layout = "circle",
                               signaling.name = paste0(sample_name, " - ", pw),
                               vertex.label.cex = 0.8,
                               title.space = 10)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] circle failed: ", e$message)})
    
    # 3) Bubble
    tryCatch({
      b <- netVisual_bubble(chat,
                            signaling = pw,
                            remove.isolate = TRUE)
      print(b)
    }, error = function(e){message("[", sample_name,"|",pw,"] bubble failed: ", e$message)})
    
    # 4) Heatmap
    tryCatch({
      p <- netVisual_heatmap(chat, signaling = pw)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] heatmap failed: ", e$message)})
    
    # 5) Contribution (per pathway)
    tryCatch({
      c <- netAnalysis_contribution(chat, signaling = pw)
      print(c)
    }, error = function(e){message("[", sample_name,"|",pw,"] contribution failed: ", e$message)})
  }
  
  dev.off()
  message("Saved exploratory PDF for sample: ", safe_name)
}))

```


