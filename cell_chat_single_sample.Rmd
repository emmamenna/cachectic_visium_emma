---
title: "cell_communication"
output: html_document
date: "2025-09-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(arrow)
library(Banksy)
library(BiocParallel)
library(DropletUtils)
library(dplyr)
library(edgeR)
library(ggplot2)
library(graphics)
library(igraph)
library(jsonlite)
library(Matrix)
library(OSTA.data)
library(patchwork)
library(pheatmap)
library(S4Vectors)
library(scDblFinder)
library(scater)
library(scran)
library(scuttle)
library(SingleCellExperiment)
library(SpatialExperiment)
library(SummarizedExperiment)
library(tidyr)
library(VisiumIO)
library(spacexr)
library(SpotSweeper)
library(ggspavis)
library(CellChat)
library(Seurat)
library(SeuratDisk)
library(SpaNorm)
```

CellChat ha creato un'estensione (Jin et al., 2023) per la trascrittomica spaziale. Tanti altri metodi sono in Python, qualcuno in R (vedi articoli).
Prendo un po' il codice dal multiome.

#Normalizzazione e filtraggio (OGGETTO SALVATO, NON RIPETERE)
```{r}
load("~/subset_list.RData")

#filter genes (expressed in at least 1% of spots)
 subset_list <- lapply(subset_list, function(spe) {
   keep <- filterGenes(spe, prop = 0.01)
   print(table(keep)) 
   spe[keep, ]
})

#Filtro gli NA della deconvoluzione e gli spot con conteggi nulli
#(tanto tranne il blocco 7 sono solo esterni, ossia effettivo rumore - tessuto connettivo)
subset_list <- lapply(subset_list, function(spe) {
   keep <- !is.na(spe$cell_type) & colSums(counts(spe)) > 0
   print(table(keep)) #vedo quanto sto togliendo (molta variabilità: da poche decine a poche migliaia)
   spe[,keep]
})

#Normalizzazione single-cell 
# subset_list <- lapply(subset_list, function(spe) {
#   set.seed(92)
#   spe <- logNormCounts(spe)
# })

#Normalizzazione spaziale 
# ?SpaNorm
subset_list <- lapply(subset_list, function(spe) {
  set.seed(92)
  spe <- SpaNorm(spe, sample.p = 0.10, maxn.psi = 200, maxit.nb=15, maxit.psi = 5, df.tps = 3)
})
#senza filtraggio dei geni è eterna

```

#CELL CHAT SU UN CAMPIONE ALLA VOLTA
CellChat identifica ligandi e recettori sovra-espressi per ogni tipo di cellule
(identifyOverExpressedGenes) e le interazioni ligando/recettore sovra-espresse 
(identifyOverExpressedInteractions). Dopodiché associa a quelle interazioni una
probabilità basata sull'espressione media del ligando e del recettore (di 2 tipi cellulari)
e su una tecnica di network propagation (propaga l'info ai geni simili / nodi vicini).
Le interazioni significative vengono identificate con un test di permutazione sulle 
etichette dei gruppi cellulari. La stessa cosa viene fatta aggregando ligandi e recettori
per pathway. Una rete di comunicazioni intercellulari è un grafo diretto pesato che mostra
le connessioni significative tra gruppi cellulari. Poi ci sono vari modi in cui si può
studiare la similarità dei vari signaling pathways (rappresentati come ognuno come una rete).
```{r}

#funziona col filtraggio dei geni all'1% e la normalizzazione single-cell
load("~/subset_list_spanorm.RData")

#tolgo il blocco7
subset_list <- subset_list[!names(subset_list) %in% c("c26STAT3_b7","sham_b7","c26_b7")]
cellchat_list <- list()

#aggiungo i dati spatial
spatial.factors <- data.frame(
  ratio = 0.315,   #conversione micron pixel
  tol   = 4    # metà della dimensione del bin
)

cellchat_list <- lapply(subset_list, function(spx) {
  sce <- as(spx, "SingleCellExperiment")
  chat <- createCellChat(object = sce,
                         group.by = "cell_type",
                         coordinates = spatialCoords(spx),
                         spatial.factors = spatial.factors)
  chat@DB <- CellChatDB.mouse
  # chat@DB.use <-subsetDB(chat@DB,search="Secreted Signaling")

  chat <- subsetData(chat)
  chat <- identifyOverExpressedGenes(chat)
  chat <- identifyOverExpressedInteractions(chat)
  chat <- computeCommunProb(chat, type = "triMean")
  chat <- filterCommunication(chat, min.cells = 5)
  chat <- computeCommunProbPathway(chat)
  chat <- aggregateNet(chat)
  chat
})

lapply(cellchat_list, function(x){
  df.net <- subsetCommunication(x, slot.name = "netP")
  prob <- df.net %>% group_by(pathway_name) %>% summarise(sum = sum(prob))
  prob <- prob[order(prob$sum, decreasing = T), ]
}) 

```

#COMBINAZIONE RISULTATI (lascia stare)
```{r}

chat@net$prob #una matrice per ogni interazione LR
chat@net$pval #e p-value associati -> le probabilità si azzerano quando il pval non è sig.
dim(chat@net$prob) #sono 2083 in questo caso
chat@net$weight

#c'è una funzione che permette di mettere assieme gli oggetti cellchat di ogni campione
#ma mantiene comunque le cose separate.
cell_chat_sham_list <- cellchat_list[names(cellchat_list) %in% c("sham_b1","sham_b3","sham_b6")]
cell_chat_sham <- mergeCellChat(cell_chat_sham_list,
                                add.names = names(cell_chat_sham_list),
                                cell.prefix = TRUE)

cell_chat_sham@net #ci sono le 3 reti per i 3 campioni

#secondo il prof sarebbe da fare un merge a livello di probabilità
#prima che venga assegnata una significatività
#ma come? bisognerebbe andare a modificare la funzione di computeCommunProb

ci_sham <- compareInteractions(cell_chat_sham) #vuole l'oggetto merged
ci_sham@plot_env #boh ci sono un po' di confronti ma aggregati... non credo siano utili
rankNet()

#GUARDARE VIGNETTE


```


#SENZA INFO SPAZIALE X CONFRONTO
```{r}

#funziona col filtraggio dei geni all'1% e la normalizzazione single-cell
load("~/subset_list_spanorm.RData")

#tolgo il blocco7
subset_list <- subset_list[!names(subset_list) %in% c("c26STAT3_b7","sham_b7","c26_b7")]
cellchat_list <- list()

cellchat_list <- lapply(subset_list, function(spx) {
  sce <- as(spx, "SingleCellExperiment")
  chat <- createCellChat(object = sce,
                         group.by = "cell_type"
                         )
  chat@DB <- CellChatDB.mouse
  # chat@DB.use <-subsetDB(chat@DB,search="Secreted Signaling")

  chat <- subsetData(chat)
  chat <- identifyOverExpressedGenes(chat)
  chat <- identifyOverExpressedInteractions(chat)
  chat <- computeCommunProb(chat, type = "triMean")
  chat <- filterCommunication(chat, min.cells = 5)
  chat <- computeCommunProbPathway(chat)
  chat <- aggregateNet(chat)
  chat
})

lapply(cellchat_list, function(x){
  df.net <- subsetCommunication(x, slot.name = "netP")
  prob <- df.net %>% group_by(pathway_name) %>% summarise(sum = sum(prob))
  prob <- prob[order(prob$sum, decreasing = T), ]
}) 

```

#VISUALIZZAZIONE COMPLETA
```{r}
# Loop sui campioni
invisible(lapply(names(cellchat_list), function(sample_name) {
  chat <- cellchat_list[[sample_name]]
  pathways.show <- chat@netP$pathways
  
  # pulizia nome file
  safe_name <- gsub("[^[:alnum:]_\\-]", "_", sample_name)
  out_pdf <- paste0("CellChat_Exploratory_", safe_name, ".pdf")
  
  # vertex.receiver default: tutti i cluster
  n_groups <- length(unique(as.character(chat@idents)))
  vertex.receiver <- seq_len(n_groups)
  
  pdf(file = out_pdf, width = 9, height = 9)
  
  ## --- PAGINA INTRO CAMPIONE ---
  tryCatch({
    groupSize <- as.numeric(table(chat@idents))
    par(mfrow = c(1,2), xpd = TRUE)
    
    netVisual_circle(chat@net$count,
                     vertex.weight = groupSize,
                     weight.scale = TRUE,
                     label.edge = FALSE,
                     title.name = "Number of interactions")
    
    netVisual_circle(chat@net$weight,
                     vertex.weight = groupSize,
                     weight.scale = TRUE,
                     label.edge = FALSE,
                     title.name = "Interaction weights/strength")
    
    par(mfrow = c(1,1)) # reset layout
  }, error = function(e){
    message("[", sample_name, "] overview circle plots failed: ", e$message)
  })
  
  ## --- LOOP SUI PATHWAYS ---
  for (pw in pathways.show) {
    # pagina separatore
    grid::grid.newpage()
    grid::grid.text(label = paste0(sample_name, " — ", pw),
                    gp = grid::gpar(fontsize = 20, fontface = "bold"))
    
    # 1) Chord
    tryCatch({
      p <- netVisual_aggregate(chat, signaling = pw,
                               layout = "chord",
                               signaling.name = paste0(sample_name, " - ", pw),
                               vertex.label.cex = 0.8,
                               title.space = 10)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] chord failed: ", e$message)})
    
    # 2) Circle
    tryCatch({
      p <- netVisual_aggregate(chat, signaling = pw,
                               layout = "circle",
                               signaling.name = paste0(sample_name, " - ", pw),
                               vertex.label.cex = 0.8,
                               title.space = 10)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] circle failed: ", e$message)})
    
    # 3) Bubble
    tryCatch({
      b <- netVisual_bubble(chat,
                            signaling = pw,
                            remove.isolate = TRUE)
      print(b)
    }, error = function(e){message("[", sample_name,"|",pw,"] bubble failed: ", e$message)})
    
    # 4) Heatmap
    tryCatch({
      p <- netVisual_heatmap(chat, signaling = pw)
      print(p)
    }, error = function(e){message("[", sample_name,"|",pw,"] heatmap failed: ", e$message)})
    
    # 5) Contribution (per pathway)
    tryCatch({
      c <- netAnalysis_contribution(chat, signaling = pw)
      print(c)
    }, error = function(e){message("[", sample_name,"|",pw,"] contribution failed: ", e$message)})
  }
  
  dev.off()
  message("Saved exploratory PDF for sample: ", safe_name)
}))

```



